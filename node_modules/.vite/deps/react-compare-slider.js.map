{
  "version": 3,
  "sources": ["../../react-compare-slider/src/Container.tsx", "../../react-compare-slider/src/ReactCompareSliderHandle.tsx", "../../react-compare-slider/src/utils.ts", "../../react-compare-slider/src/ReactCompareSlider.tsx", "../../react-compare-slider/src/ReactCompareSliderImage.tsx"],
  "sourcesContent": ["import React, { forwardRef } from 'react';\n\nimport type { ReactCompareSliderCommonProps } from './types';\n\n/** Container for clipped item. */\nexport const ContainerClip = forwardRef<HTMLDivElement, React.HTMLProps<HTMLDivElement>>(\n  (props, ref): React.ReactElement => {\n    const style: React.CSSProperties = {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      willChange: 'clip',\n      userSelect: 'none',\n      KhtmlUserSelect: 'none',\n      MozUserSelect: 'none',\n      WebkitUserSelect: 'none',\n    };\n\n    return <div {...props} style={style} data-rcs=\"clip-item\" ref={ref} />;\n  }\n);\n\nContainerClip.displayName = 'ContainerClip';\n\n/** Container to control the handle's position. */\nexport const ContainerHandle = forwardRef<\n  HTMLDivElement,\n  React.HTMLProps<HTMLDivElement> & Pick<ReactCompareSliderCommonProps, 'portrait'>\n>(\n  ({ children, portrait }, ref): React.ReactElement => {\n    const style: React.CSSProperties = {\n      position: 'absolute',\n      top: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n    };\n\n    const innerStyle: React.CSSProperties = {\n      position: 'absolute',\n      width: portrait ? '100%' : undefined,\n      height: portrait ? undefined : '100%',\n      transform: portrait ? 'translateY(-50%)' : 'translateX(-50%)',\n      pointerEvents: 'all',\n    };\n\n    return (\n      <div style={style} data-rcs=\"handle-container\" ref={ref}>\n        <div style={innerStyle}>{children}</div>\n      </div>\n    );\n  }\n);\n\nContainerHandle.displayName = 'ThisHandleContainer';\n", "import React from 'react';\n\nimport { ReactCompareSliderCommonProps } from './types';\n\ninterface ThisArrowProps {\n  /** Whether to flip the arrow direction. */\n  flip?: boolean;\n}\n\nconst ThisArrow: React.FC<ThisArrowProps> = ({ flip }) => {\n  const style: React.CSSProperties = {\n    width: 0,\n    height: 0,\n    borderTop: '8px solid transparent',\n    borderRight: '10px solid',\n    borderBottom: '8px solid transparent',\n    transform: flip ? 'rotate(180deg)' : undefined,\n  };\n\n  return <div style={style} />;\n};\n\n/** Props for `ReactCompareSliderHandle`. */\nexport interface ReactCompareSliderHandleProps\n  extends Pick<ReactCompareSliderCommonProps, 'portrait'> {\n  /** Optional styles for handle the button. */\n  buttonStyle?: React.CSSProperties;\n  /** Optional styles for lines either side of the handle button. */\n  linesStyle?: React.CSSProperties;\n  /** Optional styles for the handle root. */\n  style?: React.CSSProperties;\n}\n\n/** Default `handle`. */\nexport const ReactCompareSliderHandle: React.FC<ReactCompareSliderHandleProps> = ({\n  portrait,\n  buttonStyle,\n  linesStyle,\n  style,\n  ...props\n}): React.ReactElement => {\n  const _style: React.CSSProperties = {\n    display: 'flex',\n    flexDirection: portrait ? 'row' : 'column',\n    placeItems: 'center',\n    height: '100%',\n    cursor: portrait ? 'ns-resize' : 'ew-resize',\n    pointerEvents: 'none',\n    color: '#fff',\n    ...style,\n  };\n\n  const _linesStyle: React.CSSProperties = {\n    flexGrow: 1,\n    height: portrait ? 2 : '100%',\n    width: portrait ? '100%' : 2,\n    backgroundColor: 'currentColor',\n    pointerEvents: 'auto',\n    boxShadow: '0 0 7px rgba(0,0,0,.35)',\n    ...linesStyle,\n  };\n\n  const _buttonStyle: React.CSSProperties = {\n    display: 'grid',\n    gridAutoFlow: 'column',\n    gap: 8,\n    placeContent: 'center',\n    flexShrink: 0,\n    width: 56,\n    height: 56,\n    borderRadius: '50%',\n    borderStyle: 'solid',\n    borderWidth: 2,\n    pointerEvents: 'auto',\n    backdropFilter: 'blur(7px)',\n    WebkitBackdropFilter: 'blur(7px)', // For Safari.\n    boxShadow: '0 0 7px rgba(0,0,0,.35)',\n    transform: portrait ? 'rotate(90deg)' : undefined,\n    ...buttonStyle,\n  };\n\n  return (\n    <div className=\"__rcs-handle-root\" {...props} style={_style}>\n      <div className=\"__rcs-handle-line\" style={_linesStyle} />\n      <div className=\"__rcs-handle-button\" style={_buttonStyle}>\n        <ThisArrow />\n        <ThisArrow flip />\n      </div>\n      <div className=\"__rcs-handle-line\" style={_linesStyle} />\n    </div>\n  );\n};\n", "import { RefObject, useCallback, useEffect, useLayoutEffect, useRef } from 'react';\n\n/**\n * Stand-alone CSS utility to make replaced elements (`img`, `video`, etc.) fit their\n * container.\n */\nexport const styleFitContainer = ({\n  boxSizing = 'border-box',\n  objectFit = 'cover',\n  objectPosition = 'center',\n  ...props\n}: React.CSSProperties = {}): React.CSSProperties => ({\n  display: 'block',\n  width: '100%',\n  height: '100%',\n  maxWidth: '100%',\n  boxSizing,\n  objectFit,\n  objectPosition,\n  ...props,\n});\n\n/** Store the previous supplied value. */\nexport const usePrevious = <T>(value: T): T => {\n  const ref = useRef<T>(value);\n\n  useEffect(() => {\n    ref.current = value;\n  });\n\n  return ref.current;\n};\n\n/**\n * Event listener binding hook.\n * @param eventName      - Event to bind to.\n * @param handler        - Callback handler.\n * @param element        - Element to bind to.\n * @param handlerOptions - Event handler options.\n */\nexport const useEventListener = (\n  eventName: EventListener['name'],\n  handler: EventListener['caller'],\n  element: EventTarget,\n  handlerOptions: AddEventListenerOptions\n): void => {\n  const savedHandler = useRef<EventListener['caller']>();\n\n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n\n  useEffect(() => {\n    // Make sure element supports addEventListener.\n    if (!(element && element.addEventListener)) return;\n\n    // Create event listener that calls handler function stored in ref.\n    const eventListener: EventListener = (event) =>\n      savedHandler.current && savedHandler.current(event);\n\n    element.addEventListener(eventName, eventListener, handlerOptions);\n\n    return (): void => {\n      element.removeEventListener(eventName, eventListener, handlerOptions);\n    };\n  }, [eventName, element, handlerOptions]);\n};\n\n/**\n * Conditionally use `useLayoutEffect` for client *or* `useEffect` for SSR.\n * @see <https://github.com/reduxjs/react-redux/blob/c581d480dd675f2645851fb006bef91aeb6ac24d/src/utils/useIsomorphicLayoutEffect.js>\n */\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' && window.document && window.document.createElement\n    ? useLayoutEffect\n    : useEffect;\n\n/** Params passed to `useResizeObserver` `handler` function. */\nexport type UseResizeObserverHandlerParams = DOMRect;\n\n/**\n * Bind resize observer callback to element.\n * @param ref       - Element to bind to.\n * @param handler   - Callback for handling entry's bounding rect.\n */\nexport const useResizeObserver = (\n  ref: RefObject<Element>,\n  handler: (entry: UseResizeObserverHandlerParams) => void\n): void => {\n  const observer = useRef<ResizeObserver>();\n\n  const observe = useCallback(() => {\n    if (ref.current && observer.current) observer.current.observe(ref.current);\n  }, [ref]);\n\n  // Bind/rebind observer when `handler` changes.\n  useIsomorphicLayoutEffect(() => {\n    observer.current = new ResizeObserver(([entry]) => handler(entry.contentRect));\n    observe();\n\n    return (): void => {\n      if (observer.current) observer.current.disconnect();\n    };\n  }, [handler, observe]);\n};\n", "import React, { useEffect, useCallback, useRef, useState } from 'react';\n\nimport { ContainerClip, ContainerHandle } from './Container';\nimport { ReactCompareSliderHandle } from './ReactCompareSliderHandle';\nimport { ReactCompareSliderCommonProps, ReactCompareSliderPropPosition } from './types';\nimport {\n  useEventListener,\n  usePrevious,\n  UseResizeObserverHandlerParams,\n  useResizeObserver,\n} from './utils';\n\n/** Comparison slider properties. */\nexport interface ReactCompareSliderProps extends Partial<ReactCompareSliderCommonProps> {\n  /** Padding to limit the slideable bounds in pixels on the X-axis (landscape) or Y-axis (portrait). */\n  boundsPadding?: number;\n  /** Whether the slider should follow the pointer on hover. */\n  changePositionOnHover?: boolean;\n  /** Custom handle component. */\n  handle?: React.ReactNode;\n  /** First item to show. */\n  itemOne: React.ReactNode;\n  /** Second item to show. */\n  itemTwo: React.ReactNode;\n  /** Whether to only change position when handle is interacted with (useful for touch devices). */\n  onlyHandleDraggable?: boolean;\n  /** Callback on position change with position as percentage. */\n  onPositionChange?: (position: ReactCompareSliderPropPosition) => void;\n}\n\n/** Properties for internal `updateInternalPosition` callback. */\ninterface UpdateInternalPositionProps\n  extends Required<Pick<ReactCompareSliderProps, 'boundsPadding' | 'portrait'>> {\n  /** X coordinate to update to (landscape). */\n  x: number;\n  /** Y coordinate to update to (portrait). */\n  y: number;\n  /** Whether to calculate using page X and Y offsets (required for pointer events). */\n  isOffset?: boolean;\n}\n\nconst EVENT_PASSIVE_PARAMS = { passive: true };\nconst EVENT_CAPTURE_PARAMS = { capture: true, passive: false };\n\n/** Root Comparison slider. */\nexport const ReactCompareSlider: React.FC<\n  ReactCompareSliderProps & React.HtmlHTMLAttributes<HTMLDivElement>\n> = ({\n  handle,\n  itemOne,\n  itemTwo,\n  onlyHandleDraggable = false,\n  onPositionChange,\n  portrait = false,\n  position = 50,\n  boundsPadding = 0,\n  changePositionOnHover = false,\n  style,\n  ...props\n}): React.ReactElement => {\n  /** DOM node of the root element. */\n  const rootContainerRef = useRef<HTMLDivElement>(null);\n  /** DOM node of the item that is clipped. */\n  const clipContainerRef = useRef<HTMLDivElement>(null);\n  /** DOM node of the handle container. */\n  const handleContainerRef = useRef<HTMLDivElement>(null);\n  /** Current position as a percentage value (initially negative to sync bounds on mount). */\n  const internalPositionPc = useRef(position);\n  /** Previous `position` prop value. */\n  const prevPropPosition = usePrevious(position);\n  /** Whether user is currently dragging. */\n  const [isDragging, setIsDragging] = useState(false);\n  /** Whether component has a `window` event binding. */\n  const hasWindowBinding = useRef(false);\n  /** Target container for pointer events. */\n  const [interactiveTarget, setInteractiveTarget] = useState<HTMLDivElement | null>();\n  /** Whether the bounds of the container element have been synchronised. */\n  const [didSyncBounds, setDidSyncBounds] = useState(false);\n\n  // Set target container for pointer events.\n  useEffect(() => {\n    setInteractiveTarget(\n      onlyHandleDraggable ? handleContainerRef.current : rootContainerRef.current\n    );\n  }, [onlyHandleDraggable]);\n\n  /** Update internal position value. */\n  const updateInternalPosition = useCallback(\n    function updateInternalCall({\n      x,\n      y,\n      isOffset,\n      portrait: _portrait,\n      boundsPadding: _boundsPadding,\n    }: UpdateInternalPositionProps) {\n      const { top, left, width, height } = (\n        rootContainerRef.current as HTMLDivElement\n      ).getBoundingClientRect();\n\n      // Early out if width or height are zero, can't calculate values\n      // from zeros.\n      if (width === 0 || height === 0) return;\n\n      /**\n       * Pixel position clamped within the container's bounds.\n       * @NOTE This does *not* take `boundsPadding` into account because we need\n       *       the full coords to correctly position the handle.\n       */\n      const positionPx = Math.min(\n        Math.max(\n          // Determine bounds based on orientation\n          _portrait\n            ? isOffset\n              ? y - top - window.pageYOffset\n              : y\n            : isOffset\n            ? x - left - window.pageXOffset\n            : x,\n          // Min value\n          0\n        ),\n        // Max value\n        _portrait ? height : width\n      );\n\n      /** Width or height with CSS scaling accounted for. */\n      const zoomScale = _portrait\n        ? height / ((rootContainerRef.current as HTMLDivElement).offsetHeight || 1)\n        : width / ((rootContainerRef.current as HTMLDivElement).offsetWidth || 1);\n\n      const adjustedPosition = positionPx / zoomScale;\n      const adjustedWidth = width / zoomScale;\n      const adjustedHeight = height / zoomScale;\n\n      /**\n       * Internal position percentage *without* bounds.\n       * @NOTE This uses the entire container bounds **without** `boundsPadding`\n       *       to get the *real* bounds.\n       */\n      const nextInternalPositionPc =\n        (adjustedPosition / (_portrait ? adjustedHeight : adjustedWidth)) * 100;\n\n      /** Whether the current pixel position meets the min/max bounds. */\n      const positionMeetsBounds = _portrait\n        ? adjustedPosition === 0 || adjustedPosition === adjustedHeight\n        : adjustedPosition === 0 || adjustedPosition === adjustedWidth;\n\n      const canSkipPositionPc =\n        nextInternalPositionPc === internalPositionPc.current &&\n        (internalPositionPc.current === 0 || internalPositionPc.current === 100);\n\n      // Early out if pixel and percentage positions are already at the min/max\n      // to prevent update spamming when the user is sliding outside of the\n      // container.\n      if (didSyncBounds && canSkipPositionPc && positionMeetsBounds) {\n        return;\n      } else {\n        setDidSyncBounds(true);\n      }\n\n      // Set new internal position.\n      internalPositionPc.current = nextInternalPositionPc;\n\n      /** Pixel position clamped to extremities *with* bounds padding. */\n      const clampedPx = Math.min(\n        // Get largest from pixel position *or* bounds padding.\n        Math.max(adjustedPosition, 0 + _boundsPadding),\n        // Use height *or* width based on orientation.\n        (_portrait ? adjustedHeight : adjustedWidth) - _boundsPadding\n      );\n\n      (clipContainerRef.current as HTMLElement).style.clip = _portrait\n        ? `rect(auto,auto,${clampedPx}px,auto)`\n        : `rect(auto,${clampedPx}px,auto,auto)`;\n\n      (handleContainerRef.current as HTMLElement).style.transform = _portrait\n        ? `translate3d(0,${clampedPx}px,0)`\n        : `translate3d(${clampedPx}px,0,0)`;\n\n      if (onPositionChange) onPositionChange(internalPositionPc.current);\n    },\n    [didSyncBounds, onPositionChange]\n  );\n\n  // Update internal position when other user controllable props change.\n  useEffect(() => {\n    const { width, height } = (\n      rootContainerRef.current as HTMLDivElement\n    ).getBoundingClientRect();\n\n    // Use current internal position if `position` hasn't changed.\n    const nextPosition =\n      position === prevPropPosition ? internalPositionPc.current : position;\n\n    updateInternalPosition({\n      portrait,\n      boundsPadding,\n      x: (width / 100) * nextPosition,\n      y: (height / 100) * nextPosition,\n    });\n  }, [portrait, position, prevPropPosition, boundsPadding, updateInternalPosition]);\n\n  /** Handle mouse/touch down. */\n  const handlePointerDown = useCallback(\n    (ev: MouseEvent | TouchEvent) => {\n      ev.preventDefault();\n\n      updateInternalPosition({\n        portrait,\n        boundsPadding,\n        isOffset: true,\n        x: ev instanceof MouseEvent ? ev.pageX : ev.touches[0].pageX,\n        y: ev instanceof MouseEvent ? ev.pageY : ev.touches[0].pageY,\n      });\n\n      setIsDragging(true);\n    },\n    [portrait, boundsPadding, updateInternalPosition]\n  );\n\n  /** Handle mouse/touch move. */\n  const handlePointerMove = useCallback(\n    function moveCall(ev: MouseEvent | TouchEvent) {\n      updateInternalPosition({\n        portrait,\n        boundsPadding,\n        isOffset: true,\n        x: ev instanceof MouseEvent ? ev.pageX : ev.touches[0].pageX,\n        y: ev instanceof MouseEvent ? ev.pageY : ev.touches[0].pageY,\n      });\n    },\n    [portrait, boundsPadding, updateInternalPosition]\n  );\n\n  /** Handle mouse/touch up. */\n  const handlePointerUp = useCallback(() => {\n    setIsDragging(false);\n  }, []);\n\n  /** Resync internal position on resize. */\n  const handleResize: (resizeProps: UseResizeObserverHandlerParams) => void = useCallback(\n    ({ width, height }) => {\n      const { width: scaledWidth, height: scaledHeight } = (\n        rootContainerRef.current as HTMLDivElement\n      ).getBoundingClientRect();\n\n      updateInternalPosition({\n        portrait,\n        boundsPadding,\n        x: ((width / 100) * internalPositionPc.current * scaledWidth) / width,\n        y: ((height / 100) * internalPositionPc.current * scaledHeight) / height,\n      });\n    },\n    [portrait, boundsPadding, updateInternalPosition]\n  );\n\n  // Allow drag outside of container while pointer is still down.\n  useEffect(() => {\n    if (isDragging && !hasWindowBinding.current) {\n      window.addEventListener('mousemove', handlePointerMove, EVENT_PASSIVE_PARAMS);\n      window.addEventListener('mouseup', handlePointerUp, EVENT_PASSIVE_PARAMS);\n      window.addEventListener('touchmove', handlePointerMove, EVENT_PASSIVE_PARAMS);\n      window.addEventListener('touchend', handlePointerUp, EVENT_PASSIVE_PARAMS);\n      hasWindowBinding.current = true;\n    }\n\n    return (): void => {\n      if (hasWindowBinding.current) {\n        window.removeEventListener('mousemove', handlePointerMove);\n        window.removeEventListener('mouseup', handlePointerUp);\n        window.removeEventListener('touchmove', handlePointerMove);\n        window.removeEventListener('touchend', handlePointerUp);\n        hasWindowBinding.current = false;\n      }\n    };\n  }, [handlePointerMove, handlePointerUp, isDragging]);\n\n  // Bind resize observer to container.\n  useResizeObserver(rootContainerRef, handleResize);\n\n  // Handle hover events on the container.\n  useEffect(() => {\n    const containerRef = rootContainerRef.current as HTMLDivElement;\n\n    const handleMouseLeave = () => {\n      if (isDragging) return;\n      handlePointerUp();\n    };\n\n    if (changePositionOnHover) {\n      containerRef.addEventListener('mousemove', handlePointerMove, EVENT_PASSIVE_PARAMS);\n      containerRef.addEventListener('mouseleave', handleMouseLeave, EVENT_PASSIVE_PARAMS);\n    }\n\n    return () => {\n      containerRef.removeEventListener('mousemove', handlePointerMove);\n      containerRef.removeEventListener('mouseleave', handleMouseLeave);\n    };\n  }, [changePositionOnHover, handlePointerMove, handlePointerUp, isDragging]);\n\n  useEventListener(\n    'mousedown',\n    handlePointerDown,\n    interactiveTarget as HTMLDivElement,\n    EVENT_CAPTURE_PARAMS\n  );\n\n  useEventListener(\n    'touchstart',\n    handlePointerDown,\n    interactiveTarget as HTMLDivElement,\n    EVENT_CAPTURE_PARAMS\n  );\n\n  // Use custom handle if requested.\n  const Handle = handle || <ReactCompareSliderHandle portrait={portrait} />;\n\n  const rootStyle: React.CSSProperties = {\n    position: 'relative',\n    overflow: 'hidden',\n    cursor: isDragging ? (portrait ? 'ns-resize' : 'ew-resize') : undefined,\n    userSelect: 'none',\n    KhtmlUserSelect: 'none',\n    msUserSelect: 'none',\n    MozUserSelect: 'none',\n    WebkitUserSelect: 'none',\n    ...style,\n  };\n\n  return (\n    <div {...props} ref={rootContainerRef} style={rootStyle} data-rcs=\"root\">\n      {itemTwo}\n      <ContainerClip ref={clipContainerRef}>{itemOne}</ContainerClip>\n      <ContainerHandle portrait={portrait} ref={handleContainerRef}>\n        {Handle}\n      </ContainerHandle>\n    </div>\n  );\n};\n", "import React from 'react';\n\nimport { styleFitContainer } from './utils';\n\n/** Props for `ReactCompareSliderImage`. */\nexport type ReactCompareSliderImageProps = React.ImgHTMLAttributes<HTMLImageElement>;\n\n/** Image with defaults from `styleFitContainer` applied. */\nexport const ReactCompareSliderImage: React.FC<ReactCompareSliderImageProps> = ({\n  style,\n  ...props\n}): React.ReactElement => {\n  const rootStyle: React.CSSProperties = styleFitContainer(style);\n\n  return <img {...props} style={rootStyle} data-rcs=\"image\" />;\n};\n"],
  "mappings": "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",
  "names": ["ContainerClip", "forwardRef", "props", "ref", "style", "position", "top", "left", "width", "height", "willChange", "userSelect", "KhtmlUserSelect", "MozUserSelect", "WebkitUserSelect", "React", "displayName", "ContainerHandle", "children", "portrait", "pointerEvents", "innerStyle", "undefined", "transform", "ThisArrow", "flip", "borderTop", "borderRight", "borderBottom", "ReactCompareSliderHandle", "buttonStyle", "linesStyle", "_style", "display", "flexDirection", "placeItems", "cursor", "color", "_linesStyle", "flexGrow", "backgroundColor", "boxShadow", "_buttonStyle", "gridAutoFlow", "gap", "placeContent", "flexShrink", "borderRadius", "borderStyle", "borderWidth", "backdropFilter", "WebkitBackdropFilter", "className", "styleFitContainer", "boxSizing", "objectFit", "objectPosition", "maxWidth", "usePrevious", "value", "useRef", "useEffect", "current", "useEventListener", "eventName", "handler", "element", "handlerOptions", "savedHandler", "addEventListener", "eventListener", "event", "removeEventListener", "useIsomorphicLayoutEffect", "window", "document", "createElement", "useLayoutEffect", "useResizeObserver", "observer", "observe", "useCallback", "ResizeObserver", "entry", "contentRect", "disconnect", "EVENT_PASSIVE_PARAMS", "passive", "EVENT_CAPTURE_PARAMS", "capture", "ReactCompareSlider", "handle", "itemOne", "itemTwo", "onlyHandleDraggable", "onPositionChange", "boundsPadding", "changePositionOnHover", "rootContainerRef", "clipContainerRef", "handleContainerRef", "internalPositionPc", "prevPropPosition", "isDragging", "setIsDragging", "useState", "hasWindowBinding", "interactiveTarget", "setInteractiveTarget", "didSyncBounds", "setDidSyncBounds", "updateInternalPosition", "updateInternalCall", "x", "y", "isOffset", "_portrait", "_boundsPadding", "getBoundingClientRect", "positionPx", "Math", "min", "max", "pageYOffset", "pageXOffset", "zoomScale", "offsetHeight", "offsetWidth", "adjustedPosition", "adjustedWidth", "adjustedHeight", "nextInternalPositionPc", "positionMeetsBounds", "canSkipPositionPc", "clampedPx", "clip", "nextPosition", "handlePointerDown", "ev", "preventDefault", "MouseEvent", "pageX", "touches", "pageY", "handlePointerMove", "moveCall", "handlePointerUp", "handleResize", "scaledWidth", "scaledHeight", "containerRef", "handleMouseLeave", "Handle", "rootStyle", "overflow", "msUserSelect", "ReactCompareSliderImage"]
}
