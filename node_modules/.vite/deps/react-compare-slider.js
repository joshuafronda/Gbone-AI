import {
  __toESM,
  require_react
} from "./chunk-5A2KPB3J.js";

// node_modules/react-compare-slider/dist/react-compare-slider.esm.js
var import_react = __toESM(require_react());
var ContainerClip = (0, import_react.forwardRef)((props, ref) => {
  const style = {
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    willChange: "clip",
    userSelect: "none",
    KhtmlUserSelect: "none",
    MozUserSelect: "none",
    WebkitUserSelect: "none"
  };
  return import_react.default.createElement("div", Object.assign({}, props, {
    style,
    "data-rcs": "clip-item",
    ref
  }));
});
ContainerClip.displayName = "ContainerClip";
var ContainerHandle = (0, import_react.forwardRef)(({
  children,
  portrait
}, ref) => {
  const style = {
    position: "absolute",
    top: 0,
    width: "100%",
    height: "100%",
    pointerEvents: "none"
  };
  const innerStyle = {
    position: "absolute",
    width: portrait ? "100%" : void 0,
    height: portrait ? void 0 : "100%",
    transform: portrait ? "translateY(-50%)" : "translateX(-50%)",
    pointerEvents: "all"
  };
  return import_react.default.createElement("div", {
    style,
    "data-rcs": "handle-container",
    ref
  }, import_react.default.createElement("div", {
    style: innerStyle
  }, children));
});
ContainerHandle.displayName = "ThisHandleContainer";
var ThisArrow = ({
  flip
}) => {
  const style = {
    width: 0,
    height: 0,
    borderTop: "8px solid transparent",
    borderRight: "10px solid",
    borderBottom: "8px solid transparent",
    transform: flip ? "rotate(180deg)" : void 0
  };
  return import_react.default.createElement("div", {
    style
  });
};
var ReactCompareSliderHandle = ({
  portrait,
  buttonStyle,
  linesStyle,
  style,
  ...props
}) => {
  const _style = {
    display: "flex",
    flexDirection: portrait ? "row" : "column",
    placeItems: "center",
    height: "100%",
    cursor: portrait ? "ns-resize" : "ew-resize",
    pointerEvents: "none",
    color: "#fff",
    ...style
  };
  const _linesStyle = {
    flexGrow: 1,
    height: portrait ? 2 : "100%",
    width: portrait ? "100%" : 2,
    backgroundColor: "currentColor",
    pointerEvents: "auto",
    boxShadow: "0 0 7px rgba(0,0,0,.35)",
    ...linesStyle
  };
  const _buttonStyle = {
    display: "grid",
    gridAutoFlow: "column",
    gap: 8,
    placeContent: "center",
    flexShrink: 0,
    width: 56,
    height: 56,
    borderRadius: "50%",
    borderStyle: "solid",
    borderWidth: 2,
    pointerEvents: "auto",
    backdropFilter: "blur(7px)",
    WebkitBackdropFilter: "blur(7px)",
    boxShadow: "0 0 7px rgba(0,0,0,.35)",
    transform: portrait ? "rotate(90deg)" : void 0,
    ...buttonStyle
  };
  return import_react.default.createElement("div", Object.assign({
    className: "__rcs-handle-root"
  }, props, {
    style: _style
  }), import_react.default.createElement("div", {
    className: "__rcs-handle-line",
    style: _linesStyle
  }), import_react.default.createElement("div", {
    className: "__rcs-handle-button",
    style: _buttonStyle
  }, import_react.default.createElement(ThisArrow, null), import_react.default.createElement(ThisArrow, {
    flip: true
  })), import_react.default.createElement("div", {
    className: "__rcs-handle-line",
    style: _linesStyle
  }));
};
var styleFitContainer = ({
  boxSizing = "border-box",
  objectFit = "cover",
  objectPosition = "center",
  ...props
} = {}) => ({
  display: "block",
  width: "100%",
  height: "100%",
  maxWidth: "100%",
  boxSizing,
  objectFit,
  objectPosition,
  ...props
});
var usePrevious = (value) => {
  const ref = (0, import_react.useRef)(value);
  (0, import_react.useEffect)(() => {
    ref.current = value;
  });
  return ref.current;
};
var useEventListener = (eventName, handler, element, handlerOptions) => {
  const savedHandler = (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    savedHandler.current = handler;
  }, [handler]);
  (0, import_react.useEffect)(() => {
    if (!(element && element.addEventListener))
      return;
    const eventListener = (event) => savedHandler.current && savedHandler.current(event);
    element.addEventListener(eventName, eventListener, handlerOptions);
    return () => {
      element.removeEventListener(eventName, eventListener, handlerOptions);
    };
  }, [eventName, element, handlerOptions]);
};
var useIsomorphicLayoutEffect = typeof window !== "undefined" && window.document && window.document.createElement ? import_react.useLayoutEffect : import_react.useEffect;
var useResizeObserver = (ref, handler) => {
  const observer = (0, import_react.useRef)();
  const observe = (0, import_react.useCallback)(() => {
    if (ref.current && observer.current)
      observer.current.observe(ref.current);
  }, [ref]);
  useIsomorphicLayoutEffect(() => {
    observer.current = new ResizeObserver(([entry]) => handler(entry.contentRect));
    observe();
    return () => {
      if (observer.current)
        observer.current.disconnect();
    };
  }, [handler, observe]);
};
var EVENT_PASSIVE_PARAMS = {
  passive: true
};
var EVENT_CAPTURE_PARAMS = {
  capture: true,
  passive: false
};
var ReactCompareSlider = ({
  handle,
  itemOne,
  itemTwo,
  onlyHandleDraggable = false,
  onPositionChange,
  portrait = false,
  position = 50,
  boundsPadding = 0,
  changePositionOnHover = false,
  style,
  ...props
}) => {
  const rootContainerRef = (0, import_react.useRef)(null);
  const clipContainerRef = (0, import_react.useRef)(null);
  const handleContainerRef = (0, import_react.useRef)(null);
  const internalPositionPc = (0, import_react.useRef)(position);
  const prevPropPosition = usePrevious(position);
  const [isDragging, setIsDragging] = (0, import_react.useState)(false);
  const hasWindowBinding = (0, import_react.useRef)(false);
  const [interactiveTarget, setInteractiveTarget] = (0, import_react.useState)();
  const [didSyncBounds, setDidSyncBounds] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    setInteractiveTarget(onlyHandleDraggable ? handleContainerRef.current : rootContainerRef.current);
  }, [onlyHandleDraggable]);
  const updateInternalPosition = (0, import_react.useCallback)(function updateInternalCall({
    x,
    y,
    isOffset,
    portrait: _portrait,
    boundsPadding: _boundsPadding
  }) {
    const {
      top,
      left,
      width,
      height
    } = rootContainerRef.current.getBoundingClientRect();
    if (width === 0 || height === 0)
      return;
    const positionPx = Math.min(
      Math.max(
        // Determine bounds based on orientation
        _portrait ? isOffset ? y - top - window.pageYOffset : y : isOffset ? x - left - window.pageXOffset : x,
        // Min value
        0
      ),
      // Max value
      _portrait ? height : width
    );
    const zoomScale = _portrait ? height / (rootContainerRef.current.offsetHeight || 1) : width / (rootContainerRef.current.offsetWidth || 1);
    const adjustedPosition = positionPx / zoomScale;
    const adjustedWidth = width / zoomScale;
    const adjustedHeight = height / zoomScale;
    const nextInternalPositionPc = adjustedPosition / (_portrait ? adjustedHeight : adjustedWidth) * 100;
    const positionMeetsBounds = _portrait ? adjustedPosition === 0 || adjustedPosition === adjustedHeight : adjustedPosition === 0 || adjustedPosition === adjustedWidth;
    const canSkipPositionPc = nextInternalPositionPc === internalPositionPc.current && (internalPositionPc.current === 0 || internalPositionPc.current === 100);
    if (didSyncBounds && canSkipPositionPc && positionMeetsBounds) {
      return;
    } else {
      setDidSyncBounds(true);
    }
    internalPositionPc.current = nextInternalPositionPc;
    const clampedPx = Math.min(
      // Get largest from pixel position *or* bounds padding.
      Math.max(adjustedPosition, 0 + _boundsPadding),
      // Use height *or* width based on orientation.
      (_portrait ? adjustedHeight : adjustedWidth) - _boundsPadding
    );
    clipContainerRef.current.style.clip = _portrait ? `rect(auto,auto,${clampedPx}px,auto)` : `rect(auto,${clampedPx}px,auto,auto)`;
    handleContainerRef.current.style.transform = _portrait ? `translate3d(0,${clampedPx}px,0)` : `translate3d(${clampedPx}px,0,0)`;
    if (onPositionChange)
      onPositionChange(internalPositionPc.current);
  }, [didSyncBounds, onPositionChange]);
  (0, import_react.useEffect)(() => {
    const {
      width,
      height
    } = rootContainerRef.current.getBoundingClientRect();
    const nextPosition = position === prevPropPosition ? internalPositionPc.current : position;
    updateInternalPosition({
      portrait,
      boundsPadding,
      x: width / 100 * nextPosition,
      y: height / 100 * nextPosition
    });
  }, [portrait, position, prevPropPosition, boundsPadding, updateInternalPosition]);
  const handlePointerDown = (0, import_react.useCallback)((ev) => {
    ev.preventDefault();
    updateInternalPosition({
      portrait,
      boundsPadding,
      isOffset: true,
      x: ev instanceof MouseEvent ? ev.pageX : ev.touches[0].pageX,
      y: ev instanceof MouseEvent ? ev.pageY : ev.touches[0].pageY
    });
    setIsDragging(true);
  }, [portrait, boundsPadding, updateInternalPosition]);
  const handlePointerMove = (0, import_react.useCallback)(function moveCall(ev) {
    updateInternalPosition({
      portrait,
      boundsPadding,
      isOffset: true,
      x: ev instanceof MouseEvent ? ev.pageX : ev.touches[0].pageX,
      y: ev instanceof MouseEvent ? ev.pageY : ev.touches[0].pageY
    });
  }, [portrait, boundsPadding, updateInternalPosition]);
  const handlePointerUp = (0, import_react.useCallback)(() => {
    setIsDragging(false);
  }, []);
  const handleResize = (0, import_react.useCallback)(({
    width,
    height
  }) => {
    const {
      width: scaledWidth,
      height: scaledHeight
    } = rootContainerRef.current.getBoundingClientRect();
    updateInternalPosition({
      portrait,
      boundsPadding,
      x: width / 100 * internalPositionPc.current * scaledWidth / width,
      y: height / 100 * internalPositionPc.current * scaledHeight / height
    });
  }, [portrait, boundsPadding, updateInternalPosition]);
  (0, import_react.useEffect)(() => {
    if (isDragging && !hasWindowBinding.current) {
      window.addEventListener("mousemove", handlePointerMove, EVENT_PASSIVE_PARAMS);
      window.addEventListener("mouseup", handlePointerUp, EVENT_PASSIVE_PARAMS);
      window.addEventListener("touchmove", handlePointerMove, EVENT_PASSIVE_PARAMS);
      window.addEventListener("touchend", handlePointerUp, EVENT_PASSIVE_PARAMS);
      hasWindowBinding.current = true;
    }
    return () => {
      if (hasWindowBinding.current) {
        window.removeEventListener("mousemove", handlePointerMove);
        window.removeEventListener("mouseup", handlePointerUp);
        window.removeEventListener("touchmove", handlePointerMove);
        window.removeEventListener("touchend", handlePointerUp);
        hasWindowBinding.current = false;
      }
    };
  }, [handlePointerMove, handlePointerUp, isDragging]);
  useResizeObserver(rootContainerRef, handleResize);
  (0, import_react.useEffect)(() => {
    const containerRef = rootContainerRef.current;
    const handleMouseLeave = () => {
      if (isDragging)
        return;
      handlePointerUp();
    };
    if (changePositionOnHover) {
      containerRef.addEventListener("mousemove", handlePointerMove, EVENT_PASSIVE_PARAMS);
      containerRef.addEventListener("mouseleave", handleMouseLeave, EVENT_PASSIVE_PARAMS);
    }
    return () => {
      containerRef.removeEventListener("mousemove", handlePointerMove);
      containerRef.removeEventListener("mouseleave", handleMouseLeave);
    };
  }, [changePositionOnHover, handlePointerMove, handlePointerUp, isDragging]);
  useEventListener("mousedown", handlePointerDown, interactiveTarget, EVENT_CAPTURE_PARAMS);
  useEventListener("touchstart", handlePointerDown, interactiveTarget, EVENT_CAPTURE_PARAMS);
  const Handle = handle || import_react.default.createElement(ReactCompareSliderHandle, {
    portrait
  });
  const rootStyle = {
    position: "relative",
    overflow: "hidden",
    cursor: isDragging ? portrait ? "ns-resize" : "ew-resize" : void 0,
    userSelect: "none",
    KhtmlUserSelect: "none",
    msUserSelect: "none",
    MozUserSelect: "none",
    WebkitUserSelect: "none",
    ...style
  };
  return import_react.default.createElement("div", Object.assign({}, props, {
    ref: rootContainerRef,
    style: rootStyle,
    "data-rcs": "root"
  }), itemTwo, import_react.default.createElement(ContainerClip, {
    ref: clipContainerRef
  }, itemOne), import_react.default.createElement(ContainerHandle, {
    portrait,
    ref: handleContainerRef
  }, Handle));
};
var ReactCompareSliderImage = ({
  style,
  ...props
}) => {
  const rootStyle = styleFitContainer(style);
  return import_react.default.createElement("img", Object.assign({}, props, {
    style: rootStyle,
    "data-rcs": "image"
  }));
};
export {
  ReactCompareSlider,
  ReactCompareSliderHandle,
  ReactCompareSliderImage,
  styleFitContainer
};
//# sourceMappingURL=react-compare-slider.js.map
